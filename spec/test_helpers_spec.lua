local helpers = require("safe.test_helpers")

describe("safe.test_helpers", function()
    describe("mock_executor", function()
        it("returns pre-configured responses", function()
            local exec, calls = helpers.mock_executor({
                { true, 0 },
                { false, 1 },
            })
            local ok1, code1 = exec("cmd1")
            local ok2, code2 = exec("cmd2")
            assert.is_true(ok1)
            assert.are.equal(0, code1)
            assert.is_false(ok2)
            assert.are.equal(1, code2)
            assert.are.same({ "cmd1", "cmd2" }, calls)
        end)

        it("returns failure when responses exhausted", function()
            local exec, _calls = helpers.mock_executor({})
            local ok, code = exec("cmd")
            assert.is_false(ok)
            assert.are.equal(1, code)
        end)

        it("tracks all calls", function()
            local exec, calls = helpers.mock_executor({ { true, 0 }, { true, 0 } })
            exec("first")
            exec("second")
            assert.are.equal(2, #calls)
        end)
    end)

    describe("mock_popen", function()
        it("returns pre-configured outputs", function()
            local popen, calls = helpers.mock_popen({
                { true, "output1\n" },
                { true, "output2\n" },
            })
            local ok1, out1 = popen("cmd1")
            local ok2, out2 = popen("cmd2")
            assert.is_true(ok1)
            assert.are.equal("output1\n", out1)
            assert.is_true(ok2)
            assert.are.equal("output2\n", out2)
            assert.are.same({ "cmd1", "cmd2" }, calls)
        end)

        it("returns failure when outputs exhausted", function()
            local popen, _calls = helpers.mock_popen({})
            local ok, output = popen("cmd")
            assert.is_false(ok)
            assert.is_nil(output)
        end)
    end)

    describe("capture_output", function()
        it("captures io.write calls", function()
            local output = helpers.capture_output(function()
                io.write("hello ")
                io.write("world")
            end)
            assert.are.equal("hello world", output)
        end)

        it("returns empty string for no output", function()
            local output = helpers.capture_output(function() end)
            assert.are.equal("", output)
        end)

        it("restores io.write after function", function()
            local orig = io.write
            helpers.capture_output(function()
                io.write("captured")
            end)
            assert.are.equal(orig, io.write)
        end)

        it("restores io.write even on error", function()
            local orig = io.write
            pcall(function()
                helpers.capture_output(function()
                    error("boom")
                end)
            end)
            assert.are.equal(orig, io.write)
        end)

        it("propagates errors", function()
            assert.has.errors(function()
                helpers.capture_output(function()
                    error("test error")
                end)
            end)
        end)
    end)

    describe("assert_errors", function()
        it("passes when function throws", function()
            assert.has_no.errors(function()
                helpers.assert_errors(function()
                    error("boom")
                end)
            end)
        end)

        it("passes when error matches pattern", function()
            assert.has_no.errors(function()
                helpers.assert_errors(function()
                    error("file not found")
                end, "not found")
            end)
        end)

        it("fails when function does not throw", function()
            assert.has.errors(function()
                helpers.assert_errors(function() end)
            end)
        end)

        it("fails when pattern does not match", function()
            assert.has.errors(function()
                helpers.assert_errors(function()
                    error("wrong error")
                end, "expected pattern")
            end)
        end)

        it("passes with nil pattern", function()
            assert.has_no.errors(function()
                helpers.assert_errors(function()
                    error("any error")
                end, nil)
            end)
        end)
    end)

    describe("assert_no_errors", function()
        it("passes when function does not throw", function()
            assert.has_no.errors(function()
                helpers.assert_no_errors(function() end)
            end)
        end)

        it("fails when function throws", function()
            assert.has.errors(function()
                helpers.assert_no_errors(function()
                    error("oops")
                end)
            end)
        end)
    end)

    describe("with_temp_file", function()
        it("creates file with content", function()
            helpers.with_temp_file("hello", function(path)
                local f = io.open(path, "r")
                assert.is_not_nil(f)
                local content = f:read("*a")
                f:close()
                assert.are.equal("hello", content)
            end)
        end)

        it("cleans up file afterwards", function()
            local saved_path
            helpers.with_temp_file("temp", function(path)
                saved_path = path
            end)
            local f = io.open(saved_path, "r")
            assert.is_nil(f)
        end)

        it("cleans up even on error", function()
            local saved_path
            pcall(function()
                helpers.with_temp_file("temp", function(path)
                    saved_path = path
                    error("boom")
                end)
            end)
            local f = io.open(saved_path, "r")
            assert.is_nil(f)
        end)

        it("propagates errors", function()
            assert.has.errors(function()
                helpers.with_temp_file("temp", function(_path)
                    error("test error")
                end)
            end)
        end)
    end)

    describe("table_eq", function()
        it("returns true for equal tables", function()
            assert.is_true(helpers.table_eq({ 1, 2, 3 }, { 1, 2, 3 }))
        end)

        it("returns true for equal nested tables", function()
            assert.is_true(helpers.table_eq({ a = { b = 1 } }, { a = { b = 1 } }))
        end)

        it("returns false for different tables", function()
            assert.is_false(helpers.table_eq({ 1, 2 }, { 1, 3 }))
        end)

        it("returns false for different lengths", function()
            assert.is_false(helpers.table_eq({ 1, 2 }, { 1, 2, 3 }))
        end)

        it("returns false for different types", function()
            assert.is_false(helpers.table_eq("string", { 1 }))
        end)

        it("returns true for equal primitives", function()
            assert.is_true(helpers.table_eq(42, 42))
            assert.is_true(helpers.table_eq("hi", "hi"))
            assert.is_true(helpers.table_eq(true, true))
        end)

        it("returns false for different primitives", function()
            assert.is_false(helpers.table_eq(42, 43))
        end)

        it("returns true for empty tables", function()
            assert.is_true(helpers.table_eq({}, {}))
        end)

        it("handles mixed keys", function()
            assert.is_true(helpers.table_eq({ a = 1, [1] = "x" }, { a = 1, [1] = "x" }))
        end)

        it("detects extra keys in second table", function()
            assert.is_false(helpers.table_eq({ a = 1 }, { a = 1, b = 2 }))
        end)
    end)
end)
